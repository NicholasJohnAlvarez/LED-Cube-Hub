// =============================================================================
// LED Cube Hub - XIAO ESP32-C3 Version with LIS3DH + Sleep/Wake
// Version 2.0 - Added deep sleep with orientation-based trigger
// =============================================================================
// Features:
//   - DS2431 1-Wire EEPROM detection and read/write
//   - WS2812 LED control with dynamic segments
//   - Hot-swap detection via polling
//   - LIS3DH accelerometer for orientation/tap detection
//   - Double-tap to toggle LEDs on/off
//   - Double Z-axis inversion (flip upside down twice) to enter sleep
//   - Wake from sleep on double-tap via INT1
//   - Serial command interface
//
// Hardware:
//   - Seeed XIAO ESP32-C3
//   - WS2812 LED strip on D3
//   - DS2431 1-Wire on D10 with 1.2k-4.7k pull-up to VCC
//   - LIS3DH on I2C (D4=SDA, D5=SCL), INT1 on D1
//
// Sleep Behavior:
//   - Flip cube upside down (Z-axis inversion) twice within 2 seconds
//   - LEDs fade out, device enters deep sleep
//   - Wake via double-tap on the cube
//   - All state is reset on wake (cubes will be re-scanned)
//
// Libraries needed (install via Library Manager):
//   - FastLED
//   - OneWire
//   - Adafruit LIS3DH
//   - Adafruit Unified Sensor
// =============================================================================

#include <FastLED.h>
#include <OneWire.h>
#include <Wire.h>
#include <Adafruit_LIS3DH.h>
#include <Adafruit_Sensor.h>
#include "esp_sleep.h"

// =============================================================================
// Version Information
// =============================================================================
#define FIRMWARE_VERSION "2.0"
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

// =============================================================================
// Pin Definitions (XIAO ESP32-C3)
// =============================================================================
#define PIN_LED_DATA    D3   // WS2812 data (GPIO4)
#define PIN_ONEWIRE     D10  // DS2431 1-Wire bus (GPIO21)
#define PIN_I2C_SDA     D4   // LIS3DH I2C SDA (GPIO6)
#define PIN_I2C_SCL     D5   // LIS3DH I2C SCL (GPIO7)
#define PIN_LIS3DH_INT  D1   // LIS3DH INT1 pin (GPIO2) - WAKEUP CAPABLE

// =============================================================================
// Configuration
// =============================================================================
#define MAX_CUBES       8
#define MAX_TOTAL_LEDS  300
#define DS2431_FAMILY   0x2D

// Timing
#define ONEWIRE_POLL_MS     1000
#define ANIMATION_MS        33
#define ACCEL_UPDATE_MS     50
#define ORIENTATION_CHECK_MS 100

// Sleep Configuration
#define FLIP_DETECT_WINDOW_MS  2000  // 2 second window for double flip
#define SLEEP_FADE_MS          1000  // 1 second fade to black before sleep

// LIS3DH I2C Address (0x18 if SDO/SA0 is GND, 0x19 if SDO/SA0 is VCC)
#define LIS3DH_ADDRESS    0x18

// =============================================================================
// Cube Configuration Structure (stored in DS2431 EEPROM)
// =============================================================================
struct CubeConfig {
    uint8_t  cubeType;
    uint16_t ledCount;
    uint8_t  colorOrder;
    uint8_t  brightness;
    uint8_t  reserved[27];
};

// =============================================================================
// Cube Instance (runtime tracking)
// =============================================================================
struct Cube {
    uint64_t romId;
    CubeConfig config;
    uint16_t ledStart;
    uint16_t ledCount;
    bool active;
};

// =============================================================================
// Global Variables
// =============================================================================
OneWire oneWire(PIN_ONEWIRE);
CRGB leds[MAX_TOTAL_LEDS];
Adafruit_LIS3DH lis3dh = Adafruit_LIS3DH();

Cube cubes[MAX_CUBES];
int cubeCount = 0;
int totalLeds = 0;

uint32_t lastPoll = 0;
uint32_t lastAnim = 0;
uint32_t lastAccel = 0;
uint32_t lastOrientationCheck = 0;
uint8_t animFrame = 0;
uint8_t currentAnimation = 0;
bool animationRunning = true;
bool accelMode = false;
bool lis3dhFound = false;
bool ledsEnabled = true;

volatile bool doubleTapDetected = false;

uint8_t accelR = 0;
uint8_t accelG = 0;
uint8_t accelB = 0;

// Sleep/orientation tracking
bool isUpsideDown = false;
uint32_t firstFlipTime = 0;
int flipCount = 0;
bool sleepRequested = false;

// =============================================================================
// Forward Declarations
// =============================================================================
void programDevice(int deviceIdx, int cubeType, int ledCount);
void readDevice(int deviceIdx);

// =============================================================================
// I2C Register Helper Functions
// =============================================================================
void writeReg(uint8_t reg, uint8_t val) {
    Wire.beginTransmission(LIS3DH_ADDRESS);
    Wire.write(reg);
    Wire.write(val);
    Wire.endTransmission();
}

uint8_t readReg(uint8_t reg) {
    Wire.beginTransmission(LIS3DH_ADDRESS);
    Wire.write(reg);
    Wire.endTransmission();
    Wire.requestFrom((uint8_t)LIS3DH_ADDRESS, (uint8_t)1);
    return Wire.read();
}

// =============================================================================
// Interrupt Service Routine
// =============================================================================
void IRAM_ATTR onDoubleTap() {
    doubleTapDetected = true;
}

// =============================================================================
// Free RAM Function
// =============================================================================
int freeRam() {
    return ESP.getFreeHeap();
}

// =============================================================================
// Sleep Functions
// =============================================================================

void enterDeepSleep() {
    Serial.println(F("\n=== Entering Deep Sleep ==="));
    Serial.println(F("Double-tap to wake up"));
    Serial.flush();
    
    // Fade LEDs to black
    for (int brightness = 100; brightness >= 0; brightness -= 5) {
        FastLED.setBrightness(brightness);
        FastLED.show();
        delay(SLEEP_FADE_MS / 20);
    }
    
    // Turn off all LEDs
    fill_solid(leds, MAX_TOTAL_LEDS, CRGB::Black);
    FastLED.show();
    
    // Reconfigure LIS3DH for wake-on-tap only
    // Disable 6D detection
    writeReg(0x30, 0x00);  // INT1_CFG = 0 (disable 6D)
    
    // Ensure double-tap interrupt is still configured on INT1
    writeReg(0x22, 0x80);  // CTRL_REG3: I1_CLICK enabled
    writeReg(0x38, 0x20);  // CLICK_CFG: ZD enabled (double-tap on Z)
    
    // Clear any pending interrupts
    readReg(0x39);  // Read CLICK_SRC
    readReg(0x31);  // Read INT1_SRC
    
    // Configure ESP32-C3 GPIO wakeup (based on Seeed XIAO ESP32C3 documentation)
    // INT1 is on GPIO2 (D1) - wake-capable pin
    // ESP32-C3 uses esp_deep_sleep_enable_gpio_wakeup for GPIO wake
    esp_deep_sleep_enable_gpio_wakeup(BIT(D1), ESP_GPIO_WAKEUP_GPIO_HIGH);
    
    // Small delay to ensure everything is settled
    delay(100);
    
    // Enter deep sleep
    esp_deep_sleep_start();
}

void checkOrientation() {
    if (!lis3dhFound) return;
    
    // Read accelerometer
    lis3dh.read();
    int16_t z = lis3dh.z;
    
    // Check if cube is upside down (Z-axis negative, around -16384 at 2G)
    // Using threshold of -8000 to detect upside down
    bool currentlyUpsideDown = (z < -8000);
    
    // Detect transition from right-side-up to upside-down
    if (currentlyUpsideDown && !isUpsideDown) {
        uint32_t now = millis();
        
        if (flipCount == 0) {
            // First flip detected
            flipCount = 1;
            firstFlipTime = now;
            Serial.println(F("First flip detected (upside down)"));
        }
        else if (flipCount == 1 && (now - firstFlipTime) < FLIP_DETECT_WINDOW_MS) {
            // Second flip within time window
            flipCount = 2;
            Serial.println(F("Second flip detected - initiating sleep!"));
            sleepRequested = true;
        }
        else if ((now - firstFlipTime) >= FLIP_DETECT_WINDOW_MS) {
            // Time window expired, restart count
            flipCount = 1;
            firstFlipTime = now;
            Serial.println(F("First flip detected (timer reset)"));
        }
    }
    
    // Reset flip counter if time window expires
    if (flipCount > 0 && (millis() - firstFlipTime) >= FLIP_DETECT_WINDOW_MS) {
        if (flipCount < 2) {
            Serial.println(F("Flip timeout - counter reset"));
        }
        flipCount = 0;
    }
    
    isUpsideDown = currentlyUpsideDown;
}

// =============================================================================
// LIS3DH Functions
// =============================================================================

bool initLIS3DH() {
    Wire.begin(PIN_I2C_SDA, PIN_I2C_SCL);
    
    if (!lis3dh.begin(LIS3DH_ADDRESS)) {
        Serial.println(F("LIS3DH not found!"));
        return false;
    }
    
    Serial.println(F("LIS3DH found!"));
    
    // Configure LIS3DH
    lis3dh.setRange(LIS3DH_RANGE_2_G);
    lis3dh.setDataRate(LIS3DH_DATARATE_100_HZ);
    
    // Configure double-tap detection for LED toggle and wake
    // CTRL_REG1 (0x20): 100Hz, all axes enabled (set by library)
    
    // CTRL_REG2 (0x21): High-pass filter for click
    writeReg(0x21, 0x04);  // HP filter enabled for click
    
    // CTRL_REG3 (0x22): Route click interrupt to INT1
    writeReg(0x22, 0x80);  // I1_CLICK enabled
    
    // CTRL_REG5 (0x24): Latch interrupt on INT1
    writeReg(0x24, 0x08);  // LIR_INT1 = 1 (latch interrupt)
    
    // CTRL_REG6 (0x25): INT1 active high (default)
    writeReg(0x25, 0x00);
    
    // CLICK_CFG (0x38): Enable double-tap on Z axis
    writeReg(0x38, 0x20);  // ZD enabled (double-tap on Z)
    
    // Click timing parameters (tuned for reliable detection)
    writeReg(0x3A, 0x18);  // CLICK_THS: ~0.38G threshold
    writeReg(0x3B, 0x20);  // TIME_LIMIT: 320ms
    writeReg(0x3C, 0x10);  // TIME_LATENCY: 160ms
    writeReg(0x3D, 0x70);  // TIME_WINDOW: 1120ms
    
    // Configure 6D orientation detection (for sleep trigger)
    // INT1_CFG (0x30): Enable 6D detection on INT1 with OR combination
    writeReg(0x30, 0x7F);  // Enable all axes, OR combination, 6D enabled
    
    // INT1_THS (0x32): Threshold for orientation change (tune as needed)
    writeReg(0x32, 0x20);  // ~500mg threshold
    
    // INT1_DURATION (0x33): Minimum duration for stable detection
    writeReg(0x33, 0x02);  // 20ms at 100Hz
    
    // Clear any pending interrupts
    readReg(0x39);  // Read CLICK_SRC
    readReg(0x31);  // Read INT1_SRC
    
    // Setup hardware interrupt
    pinMode(PIN_LIS3DH_INT, INPUT);
    attachInterrupt(digitalPinToInterrupt(PIN_LIS3DH_INT), onDoubleTap, RISING);
    
    Serial.println(F("  Double-tap detection enabled"));
    Serial.println(F("  Tap Z-axis to toggle LEDs"));
    Serial.println(F("  Flip upside down twice within 2s to sleep"));
    
    // Debug register readback
    Serial.print(F("  CTRL_REG3: 0x")); Serial.println(readReg(0x22), HEX);
    Serial.print(F("  CTRL_REG5: 0x")); Serial.println(readReg(0x24), HEX);
    Serial.print(F("  CLICK_CFG: 0x")); Serial.println(readReg(0x38), HEX);
    Serial.print(F("  INT1_CFG: 0x")); Serial.println(readReg(0x30), HEX);
    
    Serial.print(F("  Range: "));
    switch (lis3dh.getRange()) {
        case LIS3DH_RANGE_2_G:  Serial.println(F("2G")); break;
        case LIS3DH_RANGE_4_G:  Serial.println(F("4G")); break;
        case LIS3DH_RANGE_8_G:  Serial.println(F("8G")); break;
        case LIS3DH_RANGE_16_G: Serial.println(F("16G")); break;
    }
    
    return true;
}

void handleDoubleTap() {
    if (!doubleTapDetected) return;
    doubleTapDetected = false;
    
    // Read CLICK_SRC to get tap info and clear the interrupt
    uint8_t clickSrc = readReg(0x39);
    
    // Debug output
    Serial.print(F("INT fired! CLICK_SRC: 0x"));
    Serial.println(clickSrc, HEX);
    
    // Check if it was a double-tap (bit 5 = DClick)
    if (clickSrc & 0x20) {
        ledsEnabled = !ledsEnabled;
        
        Serial.print(F("Double-tap detected! LEDs: "));
        Serial.println(ledsEnabled ? F("ON") : F("OFF"));
        
        if (!ledsEnabled) {
            fill_solid(leds, MAX_TOTAL_LEDS, CRGB::Black);
            FastLED.show();
        }
    } else if (clickSrc & 0x10) {
        // Single tap detected (bit 4)
        Serial.println(F("Single tap detected (need double-tap)"));
    }
}

void updateAccelerometer() {
    if (!lis3dhFound) return;
    
    lis3dh.read();
    
    int16_t x = lis3dh.x;
    int16_t y = lis3dh.y;
    int16_t z = lis3dh.z;
    
    accelR = constrain(abs(x) / 64, 0, 255);
    accelG = constrain(abs(y) / 64, 0, 255);
    accelB = constrain(abs(z) / 64, 0, 255);
}

void printAccelData() {
    if (!lis3dhFound) {
        Serial.println(F("LIS3DH not available"));
        return;
    }
    
    lis3dh.read();
    
    Serial.println(F("\n=== Accelerometer Data ==="));
    Serial.print(F("Raw X: ")); Serial.print(lis3dh.x);
    Serial.print(F("  Y: ")); Serial.print(lis3dh.y);
    Serial.print(F("  Z: ")); Serial.println(lis3dh.z);
    
    sensors_event_t event;
    lis3dh.getEvent(&event);
    
    Serial.print(F("Accel (m/sÂ²) X: ")); Serial.print(event.acceleration.x, 2);
    Serial.print(F("  Y: ")); Serial.print(event.acceleration.y, 2);
    Serial.print(F("  Z: ")); Serial.println(event.acceleration.z, 2);
    
    Serial.print(F("LED Color -> R: ")); Serial.print(accelR);
    Serial.print(F("  G: ")); Serial.print(accelG);
    Serial.print(F("  B: ")); Serial.println(accelB);
    
    // Orientation info
    Serial.print(F("Upside down: "));
    Serial.println(isUpsideDown ? F("YES") : F("NO"));
    Serial.print(F("Flip count: "));
    Serial.println(flipCount);
}

// =============================================================================
// DS2431 Functions
// =============================================================================

uint64_t addressToId(uint8_t* addr) {
    uint64_t id = 0;
    for (int i = 0; i < 8; i++) {
        id |= ((uint64_t)addr[i]) << (i * 8);
    }
    return id;
}

void idToAddress(uint64_t id, uint8_t* addr) {
    for (int i = 0; i < 8; i++) {
        addr[i] = (id >> (i * 8)) & 0xFF;
    }
}

bool isDS2431(uint8_t* addr) {
    if (addr[0] != DS2431_FAMILY) return false;
    return (OneWire::crc8(addr, 7) == addr[7]);
}

bool ds2431ReadPage(uint8_t* addr, uint8_t page, uint8_t* buffer) {
    if (!oneWire.reset()) return false;
    
    oneWire.select(addr);
    oneWire.write(0xF0);
    oneWire.write(page * 32);
    oneWire.write(0x00);
    
    for (int i = 0; i < 32; i++) {
        buffer[i] = oneWire.read();
    }
    return true;
}

bool ds2431Write8(uint8_t* addr, uint8_t offset, uint8_t* data) {
    if (!oneWire.reset()) return false;
    oneWire.select(addr);
    oneWire.write(0x0F);
    oneWire.write(offset);
    oneWire.write(0x00);
    for (int i = 0; i < 8; i++) {
        oneWire.write(data[i]);
    }
    
    if (!oneWire.reset()) return false;
    oneWire.select(addr);
    oneWire.write(0xAA);
    uint8_t ta1 = oneWire.read();
    uint8_t ta2 = oneWire.read();
    uint8_t es = oneWire.read();
    
    for (int i = 0; i < 8; i++) {
        if (oneWire.read() != data[i]) return false;
    }
    
    if (!oneWire.reset()) return false;
    oneWire.select(addr);
    oneWire.write(0x55);
    oneWire.write(ta1);
    oneWire.write(ta2);
    oneWire.write(es);
    
    delay(15);
    return (oneWire.read() == 0xAA);
}

bool ds2431WritePage(uint8_t* addr, uint8_t page, uint8_t* data) {
    uint8_t offset = page * 32;
    for (int chunk = 0; chunk < 4; chunk++) {
        if (!ds2431Write8(addr, offset + (chunk * 8), data + (chunk * 8))) {
            return false;
        }
    }
    return true;
}

// =============================================================================
// Cube Management
// =============================================================================

int findCube(uint64_t romId) {
    for (int i = 0; i < cubeCount; i++) {
        if (cubes[i].romId == romId) return i;
    }
    return -1;
}

bool addCube(uint64_t romId, CubeConfig* config) {
    if (cubeCount >= MAX_CUBES) return false;
    if (totalLeds + config->ledCount > MAX_TOTAL_LEDS) return false;
    
    Cube* cube = &cubes[cubeCount];
    cube->romId = romId;
    memcpy(&cube->config, config, sizeof(CubeConfig));
    cube->ledStart = totalLeds;
    cube->ledCount = config->ledCount;
    cube->active = true;
    
    totalLeds += config->ledCount;
    cubeCount++;
    
    Serial.print(F("Added cube: LEDs "));
    Serial.print(cube->ledStart);
    Serial.print(F("-"));
    Serial.println(cube->ledStart + cube->ledCount - 1);
    
    for (int i = cube->ledStart; i < cube->ledStart + cube->ledCount; i++) {
        leds[i] = CRGB::Green;
    }
    FastLED.show();
    delay(200);
    for (int i = cube->ledStart; i < cube->ledStart + cube->ledCount; i++) {
        leds[i] = CRGB::Black;
    }
    FastLED.show();
    
    return true;
}

void removeCube(uint64_t romId) {
    int idx = findCube(romId);
    if (idx < 0) return;
    
    Serial.print(F("Removed cube at index "));
    Serial.println(idx);
    
    for (int i = cubes[idx].ledStart; i < cubes[idx].ledStart + cubes[idx].ledCount; i++) {
        leds[i] = CRGB::Black;
    }
    
    cubes[idx].active = false;
}

// =============================================================================
// 1-Wire Bus Scanning
// =============================================================================

void scanOneWireBus() {
    uint8_t addr[8];
    uint64_t foundIds[MAX_CUBES];
    int foundCount = 0;
    
    oneWire.reset_search();
    while (oneWire.search(addr) && foundCount < MAX_CUBES) {
        if (isDS2431(addr)) {
            foundIds[foundCount++] = addressToId(addr);
        }
    }
    
    for (int i = 0; i < foundCount; i++) {
        if (findCube(foundIds[i]) < 0) {
            Serial.print(F("New device: "));
            Serial.println((unsigned long)(foundIds[i] & 0xFFFFFFFF), HEX);
            
            uint8_t configAddr[8];
            idToAddress(foundIds[i], configAddr);
            
            CubeConfig config;
            if (ds2431ReadPage(configAddr, 0, (uint8_t*)&config)) {
                if (config.ledCount > 0 && config.ledCount <= 100) {
                    addCube(foundIds[i], &config);
                } else {
                    Serial.println(F("  Invalid config - needs programming"));
                }
            } else {
                Serial.println(F("  Read failed"));
            }
        }
    }
    
    for (int i = 0; i < cubeCount; i++) {
        if (!cubes[i].active) continue;
        
        bool stillPresent = false;
        for (int j = 0; j < foundCount; j++) {
            if (cubes[i].romId == foundIds[j]) {
                stillPresent = true;
                break;
            }
        }
        
        if (!stillPresent) {
            removeCube(cubes[i].romId);
        }
    }
}

// =============================================================================
// Animations
// =============================================================================

void runAnimation() {
    if (!animationRunning || !ledsEnabled) return;
    
    if (accelMode) {
        CRGB color = CRGB(accelR, accelG, accelB);
        fill_solid(leds, totalLeds, color);
        animFrame++;
        return;
    }
    
    switch (currentAnimation) {
        case 0:
            for (int i = 0; i < totalLeds; i++) {
                leds[i] = CHSV((animFrame + i * 10) % 256, 255, 200);
            }
            break;
            
        case 1:
            {
                uint8_t brightness = beatsin8(30, 50, 255);
                for (int i = 0; i < totalLeds; i++) {
                    leds[i] = CHSV(160, 255, brightness);
                }
            }
            break;
            
        case 2:
            fadeToBlackBy(leds, totalLeds, 100);
            if (totalLeds > 0) {
                leds[animFrame % totalLeds] = CRGB::Red;
            }
            break;
            
        case 3:
            fadeToBlackBy(leds, totalLeds, 50);
            if (random8() < 80 && totalLeds > 0) {
                leds[random16(totalLeds)] = CRGB::White;
            }
            break;
            
        case 4:
            fill_solid(leds, totalLeds, CRGB::White);
            break;
    }
    
    animFrame++;
}

// =============================================================================
// Serial Command Handler
// =============================================================================

void processSerial() {
    if (!Serial.available()) return;
    
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    
    if (cmd == "help" || cmd == "?") {
        Serial.println(F("\n=== LED Cube Hub (ESP32-C3 + LIS3DH) ==="));
        Serial.print(F("Firmware v")); Serial.println(FIRMWARE_VERSION);
        Serial.println(F("Commands:"));
        Serial.println(F("  status    - Show system status"));
        Serial.println(F("  scan      - Rescan 1-Wire bus"));
        Serial.println(F("  list      - List detected DS2431 devices"));
        Serial.println(F("  next      - Next animation"));
        Serial.println(F("  on        - Resume animation"));
        Serial.println(F("  off       - LEDs off"));
        Serial.println(F("  accel     - Toggle accelerometer mode (XYZ->RGB)"));
        Serial.println(F("  xyz       - Print current accelerometer data"));
        Serial.println(F("  tap       - Read CLICK_SRC register (debug)"));
        Serial.println(F("  sleep     - Enter deep sleep immediately"));
        Serial.println(F("  prog <idx> <type> <leds> - Program device"));
        Serial.println(F("  read <idx> - Read device config"));
        Serial.println(F("\nGestures:"));
        Serial.println(F("  Double-tap: Toggle LEDs on/off"));
        Serial.println(F("  Flip upside down 2x (within 2s): Enter sleep mode"));
        Serial.println(F("  Double-tap while sleeping: Wake up"));
    }
    else if (cmd == "status") {
        Serial.println(F("\n=== Status ==="));
        Serial.print(F("Firmware: v")); Serial.println(FIRMWARE_VERSION);
        Serial.print(F("Built: ")); Serial.print(BUILD_DATE); 
        Serial.print(F(" ")); Serial.println(BUILD_TIME);
        Serial.println(F("Board: XIAO ESP32-C3"));
        Serial.print(F("LIS3DH: "));
        Serial.println(lis3dhFound ? F("Found") : F("Not found"));
        Serial.print(F("LEDs enabled: "));
        Serial.println(ledsEnabled ? F("ON") : F("OFF"));
        Serial.print(F("Accel mode: "));
        Serial.println(accelMode ? F("ON") : F("OFF"));
        Serial.print(F("Cubes: "));
        Serial.println(cubeCount);
        Serial.print(F("Total LEDs: "));
        Serial.println(totalLeds);
        Serial.print(F("Animation: "));
        Serial.print(currentAnimation);
        Serial.println(animationRunning ? F(" (running)") : F(" (stopped)"));
        Serial.print(F("Free RAM: "));
        Serial.println(freeRam());
        Serial.print(F("Upside down: "));
        Serial.println(isUpsideDown ? F("YES") : F("NO"));
        Serial.print(F("Flip count: "));
        Serial.println(flipCount);
        Serial.print(F("INT1 pin state: "));
        Serial.println(digitalRead(PIN_LIS3DH_INT) ? F("HIGH") : F("LOW"));
        
        for (int i = 0; i < cubeCount; i++) {
            if (!cubes[i].active) continue;
            Serial.print(F("  Cube "));
            Serial.print(i);
            Serial.print(F(": Type="));
            Serial.print(cubes[i].config.cubeType);
            Serial.print(F(" LEDs="));
            Serial.print(cubes[i].ledStart);
            Serial.print(F("-"));
            Serial.println(cubes[i].ledStart + cubes[i].ledCount - 1);
        }
    }
    else if (cmd == "scan") {
        Serial.println(F("Scanning..."));
        scanOneWireBus();
        Serial.println(F("Done"));
    }
    else if (cmd == "list") {
        Serial.println(F("\nDS2431 devices on bus:"));
        uint8_t addr[8];
        int count = 0;
        oneWire.reset_search();
        while (oneWire.search(addr)) {
            if (isDS2431(addr)) {
                Serial.print(F("  ["));
                Serial.print(count);
                Serial.print(F("] "));
                for (int i = 0; i < 8; i++) {
                    if (addr[i] < 16) Serial.print('0');
                    Serial.print(addr[i], HEX);
                    if (i < 7) Serial.print(':');
                }
                Serial.println();
                count++;
            }
        }
        if (count == 0) {
            Serial.println(F("  None found"));
        }
    }
    else if (cmd == "next") {
        accelMode = false;
        currentAnimation = (currentAnimation + 1) % 5;
        animationRunning = true;
        ledsEnabled = true;
        Serial.print(F("Animation: "));
        Serial.println(currentAnimation);
    }
    else if (cmd == "on") {
        animationRunning = true;
        ledsEnabled = true;
        Serial.println(F("Animation resumed"));
    }
    else if (cmd == "off") {
        animationRunning = false;
        accelMode = false;
        ledsEnabled = false;
        fill_solid(leds, MAX_TOTAL_LEDS, CRGB::Black);
        FastLED.show();
        Serial.println(F("LEDs off"));
    }
    else if (cmd == "accel") {
        if (!lis3dhFound) {
            Serial.println(F("LIS3DH not available!"));
        } else {
            accelMode = !accelMode;
            animationRunning = true;
            ledsEnabled = true;
            Serial.print(F("Accelerometer mode: "));
            Serial.println(accelMode ? F("ON (X=R, Y=G, Z=B)") : F("OFF"));
        }
    }
    else if (cmd == "xyz") {
        printAccelData();
    }
    else if (cmd == "tap") {
        // Debug: manually read click source register
        uint8_t clickSrc = readReg(0x39);
        Serial.print(F("CLICK_SRC: 0x"));
        Serial.print(clickSrc, HEX);
        Serial.print(F(" ("));
        if (clickSrc & 0x40) Serial.print(F("IA "));
        if (clickSrc & 0x20) Serial.print(F("DCLICK "));
        if (clickSrc & 0x10) Serial.print(F("SCLICK "));
        if (clickSrc & 0x04) Serial.print(F("Z "));
        if (clickSrc & 0x02) Serial.print(F("Y "));
        if (clickSrc & 0x01) Serial.print(F("X "));
        Serial.println(F(")"));
        Serial.print(F("INT1 pin: "));
        Serial.println(digitalRead(PIN_LIS3DH_INT) ? F("HIGH") : F("LOW"));
    }
    else if (cmd == "sleep") {
        Serial.println(F("Entering sleep mode via command..."));
        sleepRequested = true;
    }
    else if (cmd.startsWith("prog ")) {
        int idx, type, ledCount;
        if (sscanf(cmd.c_str(), "prog %d %d %d", &idx, &type, &ledCount) == 3) {
            programDevice(idx, type, ledCount);
        } else {
            Serial.println(F("Usage: prog <idx> <type> <leds>"));
            Serial.println(F("Types: 1=Corner 2=Edge 3=Center 4=Hub"));
        }
    }
    else if (cmd.startsWith("read ")) {
        int idx = cmd.substring(5).toInt();
        readDevice(idx);
    }
    else if (cmd.length() > 0) {
        Serial.print(F("Unknown: "));
        Serial.println(cmd);
    }
}

void programDevice(int deviceIdx, int cubeType, int ledCount) {
    uint8_t addr[8];
    int count = 0;
    
    oneWire.reset_search();
    while (oneWire.search(addr)) {
        if (isDS2431(addr)) {
            if (count == deviceIdx) {
                CubeConfig config;
                memset(&config, 0, sizeof(config));
                config.cubeType = cubeType;
                config.ledCount = ledCount;
                config.colorOrder = 0;
                config.brightness = 128;
                
                Serial.print(F("Programming device "));
                Serial.print(deviceIdx);
                Serial.print(F(" as type "));
                Serial.print(cubeType);
                Serial.print(F(" with "));
                Serial.print(ledCount);
                Serial.println(F(" LEDs..."));
                
                if (ds2431WritePage(addr, 0, (uint8_t*)&config)) {
                    Serial.println(F("SUCCESS!"));
                    scanOneWireBus();
                } else {
                    Serial.println(F("FAILED!"));
                }
                return;
            }
            count++;
        }
    }
    Serial.println(F("Device not found"));
}

void readDevice(int deviceIdx) {
    uint8_t addr[8];
    int count = 0;
    
    oneWire.reset_search();
    while (oneWire.search(addr)) {
        if (isDS2431(addr)) {
            if (count == deviceIdx) {
                Serial.print(F("\nDevice "));
                Serial.print(deviceIdx);
                Serial.println(F(" config:"));
                
                CubeConfig config;
                if (ds2431ReadPage(addr, 0, (uint8_t*)&config)) {
                    Serial.print(F("  Type: "));
                    Serial.println(config.cubeType);
                    Serial.print(F("  LEDs: "));
                    Serial.println(config.ledCount);
                    Serial.print(F("  Color order: "));
                    Serial.println(config.colorOrder);
                    Serial.print(F("  Brightness: "));
                    Serial.println(config.brightness);
                } else {
                    Serial.println(F("  Read failed!"));
                }
                return;
            }
            count++;
        }
    }
    Serial.println(F("Device not found"));
}

// =============================================================================
// Setup & Loop
// =============================================================================

void setup() {
    Serial.begin(115200);
    delay(2000);
    
    Serial.println(F("\n============================="));
    Serial.println(F("     LED Cube Hub"));
    Serial.println(F("   ESP32-C3 + LIS3DH"));
    Serial.print(F("   Firmware v"));
    Serial.println(FIRMWARE_VERSION);
    Serial.println(F("=============================\n"));
    
    // Check wake reason
    esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
    if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
        Serial.println(F("*** Woke from deep sleep via double-tap! ***\n"));
    }
    
    // Initialize LIS3DH
    lis3dhFound = initLIS3DH();
    
    // Initialize FastLED with simple configuration
    FastLED.addLeds<WS2812B, PIN_LED_DATA, GRB>(leds, MAX_TOTAL_LEDS);
    FastLED.setBrightness(100);
    FastLED.clear();
    FastLED.show();
    delay(100);  // Give FastLED time to stabilize before starting animations
    
    Serial.println(F("LED pin: D3 (GPIO4)"));
    Serial.println(F("1-Wire pin: D10 (GPIO21)"));
    Serial.println(F("I2C SDA: D4 (GPIO6), SCL: D5 (GPIO7)"));
    Serial.println(F("LIS3DH INT1: D1 (GPIO2)"));
    Serial.print(F("Max cubes: "));
    Serial.println(MAX_CUBES);
    Serial.print(F("Max LEDs: "));
    Serial.println(MAX_TOTAL_LEDS);
    Serial.print(F("Free RAM: "));
    Serial.println(freeRam());
    
    Serial.println(F("\nScanning for cubes..."));
    scanOneWireBus();
    
    Serial.println(F("\nType 'help' for commands"));
    Serial.println(F("Gestures:"));
    Serial.println(F("  - Double-tap to toggle LEDs on/off"));
    Serial.println(F("  - Flip upside down 2x (within 2s) to sleep"));
    Serial.println(F("  - Double-tap while asleep to wake\n"));
}

void loop() {
    uint32_t now = millis();
    
    // Check for sleep request
    if (sleepRequested) {
        enterDeepSleep();
        // Never returns from here
    }
    
    handleDoubleTap();
    
    processSerial();
    
    if (now - lastAccel >= ACCEL_UPDATE_MS) {
        lastAccel = now;
        updateAccelerometer();
    }
    
    if (now - lastOrientationCheck >= ORIENTATION_CHECK_MS) {
        lastOrientationCheck = now;
        checkOrientation();
    }
    
    if (now - lastPoll >= ONEWIRE_POLL_MS) {
        lastPoll = now;
        scanOneWireBus();
    }
    
    if (now - lastAnim >= ANIMATION_MS) {
        lastAnim = now;
        if (totalLeds > 0) {
            runAnimation();
            FastLED.show();
        }
    }
}